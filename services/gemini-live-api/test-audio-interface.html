<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Live Audio Test Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .audio-panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .logs-panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .panel-title {
            color: #333;
            margin-bottom: 15px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
            font-size: 18px;
            font-weight: 600;
        }
        
        .audio-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .control-group {
            flex: 1;
            min-width: 200px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: 600;
            font-size: 14px;
        }
        
        input, select {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 5px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 5px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }
        
        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%);
            color: #333;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-connected {
            background: #28a745;
        }
        
        .status-disconnected {
            background: #dc3545;
        }
        
        .status-connecting {
            background: #ffc107;
        }
        
        .audio-visualizer {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
            height: 100px;
            position: relative;
            overflow: hidden;
        }
        
        .visualizer-bar {
            display: inline-block;
            width: 3px;
            background: #667eea;
            margin: 0 1px;
            border-radius: 2px;
            transition: height 0.1s ease;
        }
        
        .logs-container {
            background: #1e1e1e;
            color: #f8f8f2;
            border-radius: 5px;
            padding: 15px;
            height: 400px;
            overflow-y: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }
        
        .log-timestamp {
            color: #888;
            font-size: 11px;
        }
        
        .log-level-info {
            color: #61dafb;
        }
        
        .log-level-success {
            color: #50fa7b;
        }
        
        .log-level-warning {
            color: #ffb86c;
        }
        
        .log-level-error {
            color: #ff5555;
        }
        
        .log-level-audio {
            color: #bd93f9;
        }
        
        .log-details {
            color: #888;
            font-size: 11px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            margin-left: 20px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .session-info {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .session-info h4 {
            margin-bottom: 10px;
            color: #333;
        }
        
        .session-info p {
            margin: 5px 0;
            font-size: 14px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 15px 0;
        }
        
        .stat-box {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #667eea;
        }
        
        .stat-label {
            font-size: 11px;
            color: #666;
            margin-top: 5px;
        }
        
        .audio-level {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        
        .level-bar {
            flex: 1;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            margin: 0 10px;
            overflow: hidden;
        }
        
        .level-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #ffc107, #dc3545);
            transition: width 0.1s ease;
        }
        
        .level-text {
            font-size: 12px;
            color: #666;
            min-width: 40px;
        }
        
        .connection-status {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        
        .connection-details {
            flex: 1;
            margin-left: 10px;
        }
        
        .connection-details h4 {
            margin: 0 0 5px 0;
            font-size: 14px;
        }
        
        .connection-details p {
            margin: 0;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎤 Gemini Live Audio Test Interface</h1>
        
        <div class="main-grid">
            <!-- Audio Control Panel -->
            <div class="audio-panel">
                <div class="panel-title">🎵 Audio Controls</div>
                
                <!-- Connection Status -->
                <div class="connection-status">
                    <div class="status-indicator" id="connectionStatus"></div>
                    <div class="connection-details">
                        <h4 id="connectionTitle">Disconnected</h4>
                        <p id="connectionDetails">Click "Connect" to start audio testing</p>
                    </div>
                </div>
                
                <!-- Audio Controls -->
                <div class="audio-controls">
                    <div class="control-group">
                        <label>Agent ID:</label>
                        <select id="agentId">
                            <option value="vodafone-broadband">Vodafone Broadband</option>
                            <option value="sales-agent">Sales Agent</option>
                            <option value="support-agent">Support Agent</option>
                            <option value="custom">Custom Agent</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label>Customer Name:</label>
                        <input type="text" id="customerName" placeholder="John Doe" value="Test User">
                    </div>
                    
                    <div class="control-group">
                        <label>Audio Quality:</label>
                        <select id="audioQuality">
                            <option value="high">High Quality</option>
                            <option value="medium">Medium Quality</option>
                            <option value="low">Low Quality (Faster)</option>
                        </select>
                    </div>
                </div>
                
                <!-- Control Buttons -->
                <div style="margin-bottom: 20px;">
                    <button id="connectBtn" onclick="connectAudio()">🔗 Connect Audio</button>
                    <button id="disconnectBtn" onclick="disconnectAudio()" class="btn-danger" disabled>❌ Disconnect</button>
                    <button id="testBtn" onclick="testAudio()" class="btn-warning" disabled>🎤 Test Microphone</button>
                </div>
                
                <!-- Audio Visualizer -->
                <div class="audio-visualizer" id="audioVisualizer">
                    <div style="text-align: center; color: #666; margin-top: 30px;">
                        Audio visualization will appear here when connected
                    </div>
                </div>
                
                <!-- Audio Levels -->
                <div class="audio-level">
                    <span>Input:</span>
                    <div class="level-bar">
                        <div class="level-fill" id="inputLevel" style="width: 0%"></div>
                    </div>
                    <span class="level-text" id="inputLevelText">0%</span>
                </div>
                
                <div class="audio-level">
                    <span>Output:</span>
                    <div class="level-bar">
                        <div class="level-fill" id="outputLevel" style="width: 0%"></div>
                    </div>
                    <span class="level-text" id="outputLevelText">0%</span>
                </div>
                
                <!-- Session Info -->
                <div class="session-info" id="sessionInfo" style="display: none;">
                    <h4>Session Information</h4>
                    <p><strong>Session ID:</strong> <span id="sessionId">-</span></p>
                    <p><strong>Agent:</strong> <span id="sessionAgent">-</span></p>
                    <p><strong>Status:</strong> <span id="sessionStatus">-</span></p>
                    <p><strong>Duration:</strong> <span id="sessionDuration">-</span></p>
                </div>
                
                <!-- Statistics -->
                <div class="stats-grid" id="statsGrid" style="display: none;">
                    <div class="stat-box">
                        <div class="stat-value" id="audioChunks">0</div>
                        <div class="stat-label">Audio Chunks</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="responseTime">0ms</div>
                        <div class="stat-label">Avg Response</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="errors">0</div>
                        <div class="stat-label">Errors</div>
                    </div>
                </div>
            </div>
            
            <!-- Logs Panel -->
            <div class="logs-panel">
                <div class="panel-title">📋 Real-time Logs</div>
                
                <div style="margin-bottom: 15px;">
                    <button onclick="clearLogs()" style="margin-right: 10px;">🗑️ Clear Logs</button>
                    <button onclick="exportLogs()" class="btn-success">💾 Export Logs</button>
                    <label style="margin-left: 15px;">
                        <input type="checkbox" id="autoScroll" checked> Auto-scroll
                    </label>
                </div>
                
                <div class="logs-container" id="logsContainer">
                    <div class="log-entry">
                        <span class="log-timestamp">[System]</span>
                        <span class="log-level-info">Audio test interface loaded. Ready to connect.</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        const API_BASE = 'http://localhost:8081';
        let audioContext = null;
        let microphone = null;
        let analyser = null;
        let dataArray = null;
        let animationId = null;
        let sessionId = null;
        let isConnected = false;
        let startTime = null;
        let stats = {
            audioChunks: 0,
            responseTime: 0,
            errors: 0,
            totalResponseTime: 0,
            responseCount: 0
        };
        
        // Enhanced logging functions
        function addLog(message, level = 'info', details = null) {
            const logsContainer = document.getElementById('logsContainer');
            const timestamp = new Date().toLocaleTimeString();
            
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            
            let logContent = `<span class="log-timestamp">[${timestamp}]</span>`;
            logContent += `<span class="log-level-${level}">${message}</span>`;
            
            if (details) {
                logContent += `<br><span class="log-details">${JSON.stringify(details, null, 2)}</span>`;
            }
            
            logEntry.innerHTML = logContent;
            logsContainer.appendChild(logEntry);
            
            if (document.getElementById('autoScroll').checked) {
                logsContainer.scrollTop = logsContainer.scrollHeight;
            }
        }
        
        function addPipelineLog(step, data = null) {
            addLog(`🔧 PIPELINE: ${step}`, 'audio', data);
        }
        
        function clearLogs() {
            document.getElementById('logsContainer').innerHTML = '';
            addLog('Logs cleared', 'info');
        }
        
        function exportLogs() {
            const logs = document.getElementById('logsContainer').innerText;
            const blob = new Blob([logs], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `gemini-audio-logs-${new Date().toISOString().slice(0, 19)}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Audio visualization
        function setupAudioVisualizer() {
            const visualizer = document.getElementById('audioVisualizer');
            visualizer.innerHTML = '';
            
            for (let i = 0; i < 50; i++) {
                const bar = document.createElement('div');
                bar.className = 'visualizer-bar';
                bar.style.height = '2px';
                visualizer.appendChild(bar);
            }
        }
        
        function updateVisualizer() {
            if (!analyser || !dataArray) return;
            
            analyser.getByteFrequencyData(dataArray);
            const bars = document.querySelectorAll('.visualizer-bar');
            
            for (let i = 0; i < bars.length; i++) {
                const value = dataArray[i * 2] || 0;
                const height = (value / 255) * 80;
                bars[i].style.height = `${height}px`;
            }
            
            // Update input level
            const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;
            const level = Math.min(100, (average / 255) * 100);
            document.getElementById('inputLevel').style.width = `${level}%`;
            document.getElementById('inputLevelText').textContent = `${Math.round(level)}%`;
            
            animationId = requestAnimationFrame(updateVisualizer);
        }
        
        // Enhanced connection management with detailed logging
        async function connectAudio() {
            try {
                addPipelineLog('Starting audio connection process');
                
                // Request microphone access
                addPipelineLog('Step 1: Requesting microphone access');
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    } 
                });
                
                addPipelineLog('Step 2: Microphone access granted', {
                    trackCount: stream.getTracks().length,
                    audioTrack: stream.getAudioTracks()[0]?.label || 'Unknown'
                });
                
                // Set up audio context
                addPipelineLog('Step 3: Initializing audio context');
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                microphone = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                
                microphone.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                
                addPipelineLog('Step 4: Audio context initialized', {
                    sampleRate: audioContext.sampleRate,
                    state: audioContext.state,
                    analyserFftSize: analyser.fftSize
                });
                
                // Create Gemini Live session
                const agentId = document.getElementById('agentId').value;
                const customerName = document.getElementById('customerName').value;
                const audioQuality = document.getElementById('audioQuality').value;
                
                addPipelineLog('Step 5: Creating Gemini Live session', {
                    agentId,
                    customerName,
                    audioQuality,
                    apiBase: API_BASE
                });
                
                const response = await fetch(`${API_BASE}/api/test/create-audio-session`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        agentId, 
                        customerName,
                        audioQuality
                    })
                });
                
                const data = await response.json();
                
                addPipelineLog('Step 6: Session creation response received', {
                    success: data.success,
                    sessionId: data.sessionId,
                    callSid: data.callSid,
                    message: data.message
                });
                
                if (data.success) {
                    sessionId = data.sessionId;
                    isConnected = true;
                    startTime = Date.now();
                    
                    addPipelineLog('Step 7: Session created successfully', {
                        sessionId,
                        startTime: new Date(startTime).toISOString()
                    });
                    
                    // Debug: Log the sessionId that was just assigned
                    console.log('🔍 DEBUG: SessionId assigned:', sessionId);
                    addPipelineLog('DEBUG: SessionId captured for audio processing', {
                        sessionId,
                        timestamp: Date.now()
                    });
                    
                    // Update UI
                    updateConnectionStatus(true);
                    setupAudioVisualizer();
                    updateVisualizer();
                    updateSessionInfo();
                    updateStats();
                    
                    // Start audio processing
                    startAudioProcessing();
                    
                } else {
                    addPipelineLog('ERROR: Session creation failed', {
                        error: data.error,
                        details: data
                    });
                }
                
            } catch (error) {
                addPipelineLog('ERROR: Connection process failed', {
                    error: error.message,
                    stack: error.stack
                });
            }
        }
        
        function disconnectAudio() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            if (audioContext) {
                audioContext.close();
            }
            
            if (sessionId) {
                fetch(`${API_BASE}/api/test/end-session/${sessionId}`, { method: 'DELETE' })
                    .then(() => addLog('Session ended', 'info'))
                    .catch(err => addLog(`Error ending session: ${err.message}`, 'error'));
            }
            
            isConnected = false;
            sessionId = null;
            startTime = null;
            
            updateConnectionStatus(false);
            addLog('Audio connection disconnected', 'info');
        }
        
        function updateConnectionStatus(connected) {
            const statusIndicator = document.getElementById('connectionStatus');
            const title = document.getElementById('connectionTitle');
            const details = document.getElementById('connectionDetails');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            const testBtn = document.getElementById('testBtn');
            
            if (connected) {
                statusIndicator.className = 'status-indicator status-connected';
                title.textContent = 'Connected';
                details.textContent = `Session: ${sessionId}`;
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
                testBtn.disabled = false;
            } else {
                statusIndicator.className = 'status-indicator status-disconnected';
                title.textContent = 'Disconnected';
                details.textContent = 'Click "Connect" to start audio testing';
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                testBtn.disabled = true;
            }
        }
        
        function updateSessionInfo() {
            if (!sessionId) {
                document.getElementById('sessionInfo').style.display = 'none';
                return;
            }
            
            const duration = startTime ? Math.round((Date.now() - startTime) / 1000) : 0;
            
            document.getElementById('sessionId').textContent = sessionId;
            document.getElementById('sessionAgent').textContent = document.getElementById('agentId').value;
            document.getElementById('sessionStatus').textContent = isConnected ? 'Active' : 'Inactive';
            document.getElementById('sessionDuration').textContent = `${duration}s`;
            
            document.getElementById('sessionInfo').style.display = 'block';
        }
        
        function updateStats() {
            document.getElementById('audioChunks').textContent = stats.audioChunks;
            document.getElementById('responseTime').textContent = `${Math.round(stats.responseTime)}ms`;
            document.getElementById('errors').textContent = stats.errors;
            
            document.getElementById('statsGrid').style.display = 'grid';
        }
        
        // Enhanced audio processing with detailed pipeline logging
        function startAudioProcessing() {
            if (!isConnected || !audioContext) return;
            
            addPipelineLog('Starting audio processing pipeline');
            
            // Capture the current sessionId to ensure all subsequent requests use a stable, non-null value
            const currentSessionId = sessionId;
            if (!currentSessionId) {
                addPipelineLog('ERROR: Cannot start audio processing – sessionId is null', {
                    sessionId: currentSessionId
                });
                return;
            }

            // Debug: Log the sessionId being used for audio processing
            console.log('🔍 DEBUG: Audio processing using sessionId:', currentSessionId);
            addPipelineLog('DEBUG: Starting audio processing with sessionId', {
                sessionId: currentSessionId,
                timestamp: Date.now()
            });

            // Create audio processor
            const processor = audioContext.createScriptProcessor(4096, 1, 1);
            
            processor.onaudioprocess = async function(e) {
                const inputData = e.inputBuffer.getChannelData(0);
                
                addPipelineLog('Step 1: Audio input received', {
                    sampleRate: e.inputBuffer.sampleRate,
                    length: inputData.length,
                    duration: inputData.length / e.inputBuffer.sampleRate
                });
                
                // Convert to base64 for API
                const audioBuffer = new Float32Array(inputData);
                const audioArray = new Int16Array(audioBuffer.length);
                
                for (let i = 0; i < audioBuffer.length; i++) {
                    audioArray[i] = audioBuffer[i] * 32767;
                }
                
                const audioBase64 = btoa(String.fromCharCode(...new Uint8Array(audioArray.buffer)));
                
                addPipelineLog('Step 2: Audio converted to base64', {
                    originalLength: inputData.length,
                    base64Length: audioBase64.length,
                    compressionRatio: (audioBase64.length / inputData.length).toFixed(2)
                });
                
                // Send to Gemini Live API
                try {
                    const startTime = Date.now();
                    
                    addPipelineLog('Step 3: Sending to Gemini Live API', {
                        sessionId: currentSessionId,
                        audioDataLength: audioBase64.length,
                        timestamp: Date.now()
                    });
                    
                    const response = await fetch(`${API_BASE}/api/test/send-audio`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            sessionId: currentSessionId,
                            audioData: audioBase64,
                            timestamp: Date.now()
                        })
                    });
                    
                    const data = await response.json();
                    
                    addPipelineLog('Step 4: Received API response', {
                        success: data.success,
                        responseTime: Date.now() - startTime,
                        hasAudioResponse: false, // Will be updated after checking responses
                        hasTextResponse: false   // Will be updated after checking responses
                    });
                    
                    if (data.success) {
                        stats.audioChunks++;
                        stats.responseCount++;
                        stats.totalResponseTime += (Date.now() - startTime);
                        stats.responseTime = stats.totalResponseTime / stats.responseCount;
                        
                        // Wait a moment for Gemini to process and respond
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        
                        // Check for responses from Gemini
                        try {
                            const responseCheck = await fetch(`${API_BASE}/api/test/get-responses/${currentSessionId}`, {
                                method: 'GET',
                                headers: { 'Content-Type': 'application/json' }
                            });
                            
                            const responseData = await responseCheck.json();
                            
                            addPipelineLog('Step 5: Checked for Gemini responses', {
                                success: responseData.success,
                                sessionId: currentSessionId,
                                hasAudioResponse: responseData.hasAudioResponse || false,
                                hasTextResponse: responseData.hasTextResponse || false,
                                totalAudioResponses: responseData.totalAudioResponses || 0,
                                totalTextResponses: responseData.totalTextResponses || 0
                            });
                            
                            if (responseData.success && responseData.hasAudioResponse) {
                                // Process the latest audio response
                                const latestAudio = responseData.audioResponses[responseData.audioResponses.length - 1];
                                
                                addPipelineLog('Step 6: Processing audio response', {
                                    audioResponseLength: latestAudio.audioData.length,
                                    mimeType: latestAudio.mimeType,
                                    responseType: 'audio'
                                });
                                
                                // Play response audio
                                playResponseAudio(latestAudio.audioData);
                            }
                            
                            if (responseData.success && responseData.hasTextResponse) {
                                // Process the latest text response
                                const latestText = responseData.textResponses[responseData.textResponses.length - 1];
                                
                                addPipelineLog('Step 7: Processing text response', {
                                    textResponse: latestText.text,
                                    responseType: 'text'
                                });
                            }
                            
                        } catch (responseError) {
                            addPipelineLog('WARNING: Failed to check for responses', {
                                error: responseError.message,
                                sessionId: currentSessionId
                            });
                        }
                        
                        updateStats();
                    } else {
                        stats.errors++;
                        addPipelineLog('ERROR: API request failed', {
                            error: data.error,
                            sessionId: currentSessionId
                        });
                    }
                    
                } catch (error) {
                    stats.errors++;
                    addPipelineLog('ERROR: Network request failed', {
                        error: error.message,
                        sessionId: currentSessionId
                    });
                }
            };
            
            microphone.connect(processor);
            processor.connect(audioContext.destination);
            
            addPipelineLog('Audio processing pipeline started successfully');
        }
        
        function playResponseAudio(audioBase64) {
            if (!audioContext) return;
            
            try {
                const audioData = atob(audioBase64);
                const audioArray = new Uint8Array(audioData.length);
                for (let i = 0; i < audioData.length; i++) {
                    audioArray[i] = audioData.charCodeAt(i);
                }
                
                const audioBuffer = audioContext.createBuffer(1, audioArray.length / 2, 24000);
                const channelData = audioBuffer.getChannelData(0);
                
                for (let i = 0; i < audioArray.length; i += 2) {
                    const sample = (audioArray[i] | (audioArray[i + 1] << 8)) / 32768;
                    channelData[i / 2] = sample;
                }
                
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);
                source.start();
                
                // Update output level
                const outputLevel = Math.random() * 100; // Simplified for demo
                document.getElementById('outputLevel').style.width = `${outputLevel}%`;
                document.getElementById('outputLevelText').textContent = `${Math.round(outputLevel)}%`;
                
            } catch (error) {
                addLog(`Error playing response audio: ${error.message}`, 'error');
            }
        }
        
        // Test functions
        function testAudio() {
            addLog('Testing microphone input...', 'info');
            
            // Simulate audio test
            setTimeout(() => {
                addLog('Microphone test completed - audio input detected', 'success');
            }, 1000);
        }
        
        // Update session info every second
        setInterval(() => {
            if (isConnected) {
                updateSessionInfo();
            }
        }, 1000);
        
        // Initialize
        window.addEventListener('load', () => {
            addLog('Audio test interface loaded successfully', 'success');
            updateConnectionStatus(false);
        });
    </script>
</body>
</html> 